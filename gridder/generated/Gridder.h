//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Gridder.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Gridder_h__
#define __Gridder_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace RoboCompGridder
{

class Gridder;
class GridderPrx;

}

namespace RoboCompGridder
{

struct TPoint
{
    float x;
    float y;
    float radius;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const float&> ice_tuple() const
    {
        return std::tie(x, y, radius);
    }
};

using TPointVector = ::std::vector<TPoint>;

using TPath = ::std::vector<TPoint>;

using TPaths = ::std::vector<TPath>;

struct TDimensions
{
    float left;
    float top;
    float width;
    float height;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const float&, const float&> ice_tuple() const
    {
        return std::tie(left, top, width, height);
    }
};

struct Result
{
    ::RoboCompGridder::TPaths paths;
    long long int timestamp;
    ::std::string errorMsg;
    bool valid;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::RoboCompGridder::TPaths&, const long long int&, const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(paths, timestamp, errorMsg, valid);
    }
};

struct TCell
{
    int x;
    int y;
    ::Ice::Byte cost;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const ::Ice::Byte&> ice_tuple() const
    {
        return std::tie(x, y, cost);
    }
};

using TCellVector = ::std::vector<TCell>;

struct Map
{
    int tileSize;
    ::RoboCompGridder::TCellVector cells;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::RoboCompGridder::TCellVector&> ice_tuple() const
    {
        return std::tie(tileSize, cells);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace RoboCompGridder
{

class Gridder : public virtual ::Ice::Object
{
public:

    using ProxyType = GridderPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool IsPathBlocked(TPath path, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_IsPathBlocked(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool LineOfSightToTarget(TPoint source, TPoint target, float robotRadius, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_LineOfSightToTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TPoint getClosestFreePoint(TPoint source, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getClosestFreePoint(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TDimensions getDimensions(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getDimensions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Map getMap(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getMap(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Result getPaths(TPoint source, TPoint target, int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, float safetyFactor, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getPaths(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setGridDimensions(TDimensions dimensions, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setGridDimensions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Result setLocationAndGetPath(TPoint source, TPoint target, TPointVector freePoints, TPointVector obstaclePoints, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setLocationAndGetPath(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace RoboCompGridder
{

class GridderPrx : public virtual ::Ice::Proxy<GridderPrx, ::Ice::ObjectPrx>
{
public:

    bool IsPathBlocked(const TPath& path, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_IsPathBlocked, path, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto IsPathBlockedAsync(const TPath& path, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_IsPathBlocked, path, context);
    }

    ::std::function<void()>
    IsPathBlockedAsync(const TPath& path,
                       ::std::function<void(bool)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_IsPathBlocked, path, context);
    }

    /// \cond INTERNAL
    void _iceI_IsPathBlocked(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const TPath&, const ::Ice::Context&);
    /// \endcond

    bool LineOfSightToTarget(const TPoint& source, const TPoint& target, float robotRadius, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_LineOfSightToTarget, source, target, robotRadius, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto LineOfSightToTargetAsync(const TPoint& source, const TPoint& target, float robotRadius, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_LineOfSightToTarget, source, target, robotRadius, context);
    }

    ::std::function<void()>
    LineOfSightToTargetAsync(const TPoint& source, const TPoint& target, float robotRadius,
                             ::std::function<void(bool)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_LineOfSightToTarget, source, target, robotRadius, context);
    }

    /// \cond INTERNAL
    void _iceI_LineOfSightToTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const TPoint&, const TPoint&, float, const ::Ice::Context&);
    /// \endcond

    TPoint getClosestFreePoint(const TPoint& source, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::TPoint>(true, this, &GridderPrx::_iceI_getClosestFreePoint, source, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getClosestFreePointAsync(const TPoint& source, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::TPoint>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::TPoint, P>(false, this, &GridderPrx::_iceI_getClosestFreePoint, source, context);
    }

    ::std::function<void()>
    getClosestFreePointAsync(const TPoint& source,
                             ::std::function<void(::RoboCompGridder::TPoint)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::TPoint>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getClosestFreePoint, source, context);
    }

    /// \cond INTERNAL
    void _iceI_getClosestFreePoint(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::TPoint>>&, const TPoint&, const ::Ice::Context&);
    /// \endcond

    TDimensions getDimensions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::TDimensions>(true, this, &GridderPrx::_iceI_getDimensions, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getDimensionsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::TDimensions>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::TDimensions, P>(false, this, &GridderPrx::_iceI_getDimensions, context);
    }

    ::std::function<void()>
    getDimensionsAsync(::std::function<void(::RoboCompGridder::TDimensions)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::TDimensions>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getDimensions, context);
    }

    /// \cond INTERNAL
    void _iceI_getDimensions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::TDimensions>>&, const ::Ice::Context&);
    /// \endcond

    Map getMap(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::Map>(true, this, &GridderPrx::_iceI_getMap, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getMapAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::Map>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::Map, P>(false, this, &GridderPrx::_iceI_getMap, context);
    }

    ::std::function<void()>
    getMapAsync(::std::function<void(::RoboCompGridder::Map)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::Map>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getMap, context);
    }

    /// \cond INTERNAL
    void _iceI_getMap(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::Map>>&, const ::Ice::Context&);
    /// \endcond

    Result getPaths(const TPoint& source, const TPoint& target, int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, float safetyFactor, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::Result>(true, this, &GridderPrx::_iceI_getPaths, source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getPathsAsync(const TPoint& source, const TPoint& target, int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, float safetyFactor, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::Result>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::Result, P>(false, this, &GridderPrx::_iceI_getPaths, source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context);
    }

    ::std::function<void()>
    getPathsAsync(const TPoint& source, const TPoint& target, int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, float safetyFactor,
                  ::std::function<void(::RoboCompGridder::Result)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::Result>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getPaths, source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context);
    }

    /// \cond INTERNAL
    void _iceI_getPaths(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::Result>>&, const TPoint&, const TPoint&, int, bool, bool, float, const ::Ice::Context&);
    /// \endcond

    bool setGridDimensions(const TDimensions& dimensions, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_setGridDimensions, dimensions, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setGridDimensionsAsync(const TDimensions& dimensions, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_setGridDimensions, dimensions, context);
    }

    ::std::function<void()>
    setGridDimensionsAsync(const TDimensions& dimensions,
                           ::std::function<void(bool)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_setGridDimensions, dimensions, context);
    }

    /// \cond INTERNAL
    void _iceI_setGridDimensions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const TDimensions&, const ::Ice::Context&);
    /// \endcond

    Result setLocationAndGetPath(const TPoint& source, const TPoint& target, const TPointVector& freePoints, const TPointVector& obstaclePoints, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::Result>(true, this, &GridderPrx::_iceI_setLocationAndGetPath, source, target, freePoints, obstaclePoints, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setLocationAndGetPathAsync(const TPoint& source, const TPoint& target, const TPointVector& freePoints, const TPointVector& obstaclePoints, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::Result>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::Result, P>(false, this, &GridderPrx::_iceI_setLocationAndGetPath, source, target, freePoints, obstaclePoints, context);
    }

    ::std::function<void()>
    setLocationAndGetPathAsync(const TPoint& source, const TPoint& target, const TPointVector& freePoints, const TPointVector& obstaclePoints,
                               ::std::function<void(::RoboCompGridder::Result)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::Result>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_setLocationAndGetPath, source, target, freePoints, obstaclePoints, context);
    }

    /// \cond INTERNAL
    void _iceI_setLocationAndGetPath(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::Result>>&, const TPoint&, const TPoint&, const TPointVector&, const TPointVector&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    GridderPrx() = default;
    friend ::std::shared_ptr<GridderPrx> IceInternal::createProxy<GridderPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::RoboCompGridder::TPoint>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompGridder::TPoint, S>
{
    static void read(S* istr, ::RoboCompGridder::TPoint& v)
    {
        istr->readAll(v.x, v.y, v.radius);
    }
};

template<>
struct StreamableTraits<::RoboCompGridder::TDimensions>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompGridder::TDimensions, S>
{
    static void read(S* istr, ::RoboCompGridder::TDimensions& v)
    {
        istr->readAll(v.left, v.top, v.width, v.height);
    }
};

template<>
struct StreamableTraits<::RoboCompGridder::Result>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompGridder::Result, S>
{
    static void read(S* istr, ::RoboCompGridder::Result& v)
    {
        istr->readAll(v.paths, v.timestamp, v.errorMsg, v.valid);
    }
};

template<>
struct StreamableTraits<::RoboCompGridder::TCell>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompGridder::TCell, S>
{
    static void read(S* istr, ::RoboCompGridder::TCell& v)
    {
        istr->readAll(v.x, v.y, v.cost);
    }
};

template<>
struct StreamableTraits<::RoboCompGridder::Map>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompGridder::Map, S>
{
    static void read(S* istr, ::RoboCompGridder::Map& v)
    {
        istr->readAll(v.tileSize, v.cells);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace RoboCompGridder
{

using GridderPtr = ::std::shared_ptr<Gridder>;
using GridderPrxPtr = ::std::shared_ptr<GridderPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace RoboCompGridder
{

class Gridder;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Gridder>&);
::IceProxy::Ice::Object* upCast(Gridder*);
/// \endcond

}

}

namespace RoboCompGridder
{

class Gridder;
/// \cond INTERNAL
::Ice::Object* upCast(Gridder*);
/// \endcond
typedef ::IceInternal::Handle< Gridder> GridderPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompGridder::Gridder> GridderPrx;
typedef GridderPrx GridderPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(GridderPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace RoboCompGridder
{

struct TPoint
{
    ::Ice::Float x;
    ::Ice::Float y;
    ::Ice::Float radius;
};

typedef ::std::vector<TPoint> TPointVector;

typedef ::std::vector<TPoint> TPath;

typedef ::std::vector<TPath> TPaths;

struct TDimensions
{
    ::Ice::Float left;
    ::Ice::Float top;
    ::Ice::Float width;
    ::Ice::Float height;
};

struct Result
{
    ::RoboCompGridder::TPaths paths;
    ::Ice::Long timestamp;
    ::std::string errorMsg;
    bool valid;
};

struct TCell
{
    ::Ice::Int x;
    ::Ice::Int y;
    ::Ice::Byte cost;

    bool operator==(const TCell& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(x != rhs_.x)
        {
            return false;
        }
        if(y != rhs_.y)
        {
            return false;
        }
        if(cost != rhs_.cost)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TCell& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(x < rhs_.x)
        {
            return true;
        }
        else if(rhs_.x < x)
        {
            return false;
        }
        if(y < rhs_.y)
        {
            return true;
        }
        else if(rhs_.y < y)
        {
            return false;
        }
        if(cost < rhs_.cost)
        {
            return true;
        }
        else if(rhs_.cost < cost)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TCell& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const TCell& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const TCell& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const TCell& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<TCell> TCellVector;

struct Map
{
    ::Ice::Int tileSize;
    ::RoboCompGridder::TCellVector cells;
};

}

namespace RoboCompGridder
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_IsPathBlocked.
 */
class Callback_Gridder_IsPathBlocked_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_IsPathBlocked_Base> Callback_Gridder_IsPathBlockedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_LineOfSightToTarget.
 */
class Callback_Gridder_LineOfSightToTarget_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_LineOfSightToTarget_Base> Callback_Gridder_LineOfSightToTargetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getClosestFreePoint.
 */
class Callback_Gridder_getClosestFreePoint_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getClosestFreePoint_Base> Callback_Gridder_getClosestFreePointPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getDimensions.
 */
class Callback_Gridder_getDimensions_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getDimensions_Base> Callback_Gridder_getDimensionsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getMap.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getMap.
 */
class Callback_Gridder_getMap_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getMap_Base> Callback_Gridder_getMapPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getPaths.
 */
class Callback_Gridder_getPaths_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getPaths_Base> Callback_Gridder_getPathsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setGridDimensions.
 */
class Callback_Gridder_setGridDimensions_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_setGridDimensions_Base> Callback_Gridder_setGridDimensionsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setLocationAndGetPath.
 */
class Callback_Gridder_setLocationAndGetPath_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_setLocationAndGetPath_Base> Callback_Gridder_setLocationAndGetPathPtr;

}

namespace IceProxy
{

namespace RoboCompGridder
{

class Gridder : public virtual ::Ice::Proxy<Gridder, ::IceProxy::Ice::Object>
{
public:

    bool IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_IsPathBlocked(_iceI_begin_IsPathBlocked(path, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_IsPathBlocked(path, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsPathBlocked(path, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsPathBlocked(path, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::RoboCompGridder::Callback_Gridder_IsPathBlockedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsPathBlocked(path, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_IsPathBlockedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsPathBlocked(path, context, cb, cookie);
    }

    bool end_IsPathBlocked(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_IsPathBlocked(const ::RoboCompGridder::TPath&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_LineOfSightToTarget(_iceI_begin_LineOfSightToTarget(source, target, robotRadius, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_LineOfSightToTarget(source, target, robotRadius, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LineOfSightToTarget(source, target, robotRadius, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LineOfSightToTarget(source, target, robotRadius, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::RoboCompGridder::Callback_Gridder_LineOfSightToTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LineOfSightToTarget(source, target, robotRadius, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_LineOfSightToTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LineOfSightToTarget(source, target, robotRadius, context, cb, cookie);
    }

    bool end_LineOfSightToTarget(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint&, const ::RoboCompGridder::TPoint&, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::TPoint getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getClosestFreePoint(_iceI_begin_getClosestFreePoint(source, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getClosestFreePoint(source, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClosestFreePoint(source, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClosestFreePoint(source, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::Callback_Gridder_getClosestFreePointPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClosestFreePoint(source, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getClosestFreePointPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClosestFreePoint(source, context, cb, cookie);
    }

    ::RoboCompGridder::TPoint end_getClosestFreePoint(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getClosestFreePoint(const ::RoboCompGridder::TPoint&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::TDimensions getDimensions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getDimensions(_iceI_begin_getDimensions(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getDimensions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getDimensions(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDimensions(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDimensions(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDimensions(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDimensions(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDimensions(const ::RoboCompGridder::Callback_Gridder_getDimensionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDimensions(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDimensions(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getDimensionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDimensions(context, cb, cookie);
    }

    ::RoboCompGridder::TDimensions end_getDimensions(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getDimensions(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::Map getMap(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getMap(_iceI_begin_getMap(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getMap(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getMap(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMap(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMap(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMap(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMap(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMap(const ::RoboCompGridder::Callback_Gridder_getMapPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMap(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMap(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getMapPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMap(context, cb, cookie);
    }

    ::RoboCompGridder::Map end_getMap(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getMap(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::Result getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getPaths(_iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::RoboCompGridder::Callback_Gridder_getPathsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getPathsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context, cb, cookie);
    }

    ::RoboCompGridder::Result end_getPaths(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getPaths(const ::RoboCompGridder::TPoint&, const ::RoboCompGridder::TPoint&, ::Ice::Int, bool, bool, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setGridDimensions(_iceI_begin_setGridDimensions(dimensions, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setGridDimensions(dimensions, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setGridDimensions(dimensions, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setGridDimensions(dimensions, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::RoboCompGridder::Callback_Gridder_setGridDimensionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setGridDimensions(dimensions, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_setGridDimensionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setGridDimensions(dimensions, context, cb, cookie);
    }

    bool end_setGridDimensions(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setGridDimensions(const ::RoboCompGridder::TDimensions&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::Result setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setLocationAndGetPath(_iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::RoboCompGridder::Callback_Gridder_setLocationAndGetPathPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_setLocationAndGetPathPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, context, cb, cookie);
    }

    ::RoboCompGridder::Result end_setLocationAndGetPath(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint&, const ::RoboCompGridder::TPoint&, const ::RoboCompGridder::TPointVector&, const ::RoboCompGridder::TPointVector&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace RoboCompGridder
{

class Gridder : public virtual ::Ice::Object
{
public:

    typedef GridderPrx ProxyType;
    typedef GridderPtr PointerType;

    virtual ~Gridder();

#ifdef ICE_CPP11_COMPILER
    Gridder() = default;
    Gridder(const Gridder&) = default;
    Gridder& operator=(const Gridder&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool IsPathBlocked(const TPath& path, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_IsPathBlocked(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool LineOfSightToTarget(const TPoint& source, const TPoint& target, ::Ice::Float robotRadius, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_LineOfSightToTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TPoint getClosestFreePoint(const TPoint& source, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getClosestFreePoint(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TDimensions getDimensions(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getDimensions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Map getMap(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getMap(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Result getPaths(const TPoint& source, const TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getPaths(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setGridDimensions(const TDimensions& dimensions, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setGridDimensions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Result setLocationAndGetPath(const TPoint& source, const TPoint& target, const TPointVector& freePoints, const TPointVector& obstaclePoints, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setLocationAndGetPath(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Gridder& lhs, const Gridder& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Gridder& lhs, const Gridder& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::RoboCompGridder::TPoint>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::TPoint, S>
{
    static void write(S* ostr, const ::RoboCompGridder::TPoint& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.radius);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::TPoint, S>
{
    static void read(S* istr, ::RoboCompGridder::TPoint& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.radius);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::TDimensions>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::TDimensions, S>
{
    static void write(S* ostr, const ::RoboCompGridder::TDimensions& v)
    {
        ostr->write(v.left);
        ostr->write(v.top);
        ostr->write(v.width);
        ostr->write(v.height);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::TDimensions, S>
{
    static void read(S* istr, ::RoboCompGridder::TDimensions& v)
    {
        istr->read(v.left);
        istr->read(v.top);
        istr->read(v.width);
        istr->read(v.height);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::Result>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::Result, S>
{
    static void write(S* ostr, const ::RoboCompGridder::Result& v)
    {
        ostr->write(v.paths);
        ostr->write(v.timestamp);
        ostr->write(v.errorMsg);
        ostr->write(v.valid);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::Result, S>
{
    static void read(S* istr, ::RoboCompGridder::Result& v)
    {
        istr->read(v.paths);
        istr->read(v.timestamp);
        istr->read(v.errorMsg);
        istr->read(v.valid);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::TCell>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::TCell, S>
{
    static void write(S* ostr, const ::RoboCompGridder::TCell& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.cost);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::TCell, S>
{
    static void read(S* istr, ::RoboCompGridder::TCell& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.cost);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::Map>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::Map, S>
{
    static void write(S* ostr, const ::RoboCompGridder::Map& v)
    {
        ostr->write(v.tileSize);
        ostr->write(v.cells);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::Map, S>
{
    static void read(S* istr, ::RoboCompGridder::Map& v)
    {
        istr->read(v.tileSize);
        istr->read(v.cells);
    }
};

}
/// \endcond

namespace RoboCompGridder
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_IsPathBlocked.
 */
template<class T>
class CallbackNC_Gridder_IsPathBlocked : public Callback_Gridder_IsPathBlocked_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_IsPathBlocked(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_IsPathBlocked(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 */
template<class T> Callback_Gridder_IsPathBlockedPtr
newCallback_Gridder_IsPathBlocked(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_IsPathBlocked<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 */
template<class T> Callback_Gridder_IsPathBlockedPtr
newCallback_Gridder_IsPathBlocked(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_IsPathBlocked<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_IsPathBlocked.
 */
template<class T, typename CT>
class Callback_Gridder_IsPathBlocked : public Callback_Gridder_IsPathBlocked_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_IsPathBlocked(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_IsPathBlocked(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 */
template<class T, typename CT> Callback_Gridder_IsPathBlockedPtr
newCallback_Gridder_IsPathBlocked(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_IsPathBlocked<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 */
template<class T, typename CT> Callback_Gridder_IsPathBlockedPtr
newCallback_Gridder_IsPathBlocked(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_IsPathBlocked<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_LineOfSightToTarget.
 */
template<class T>
class CallbackNC_Gridder_LineOfSightToTarget : public Callback_Gridder_LineOfSightToTarget_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_LineOfSightToTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_LineOfSightToTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 */
template<class T> Callback_Gridder_LineOfSightToTargetPtr
newCallback_Gridder_LineOfSightToTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_LineOfSightToTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 */
template<class T> Callback_Gridder_LineOfSightToTargetPtr
newCallback_Gridder_LineOfSightToTarget(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_LineOfSightToTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_LineOfSightToTarget.
 */
template<class T, typename CT>
class Callback_Gridder_LineOfSightToTarget : public Callback_Gridder_LineOfSightToTarget_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_LineOfSightToTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_LineOfSightToTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 */
template<class T, typename CT> Callback_Gridder_LineOfSightToTargetPtr
newCallback_Gridder_LineOfSightToTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_LineOfSightToTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 */
template<class T, typename CT> Callback_Gridder_LineOfSightToTargetPtr
newCallback_Gridder_LineOfSightToTarget(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_LineOfSightToTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getClosestFreePoint.
 */
template<class T>
class CallbackNC_Gridder_getClosestFreePoint : public Callback_Gridder_getClosestFreePoint_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const TPoint&);

    CallbackNC_Gridder_getClosestFreePoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        TPoint ret;
        try
        {
            ret = proxy->end_getClosestFreePoint(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 */
template<class T> Callback_Gridder_getClosestFreePointPtr
newCallback_Gridder_getClosestFreePoint(const IceUtil::Handle<T>& instance, void (T::*cb)(const TPoint&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getClosestFreePoint<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 */
template<class T> Callback_Gridder_getClosestFreePointPtr
newCallback_Gridder_getClosestFreePoint(T* instance, void (T::*cb)(const TPoint&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getClosestFreePoint<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getClosestFreePoint.
 */
template<class T, typename CT>
class Callback_Gridder_getClosestFreePoint : public Callback_Gridder_getClosestFreePoint_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const TPoint&, const CT&);

    Callback_Gridder_getClosestFreePoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        TPoint ret;
        try
        {
            ret = proxy->end_getClosestFreePoint(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 */
template<class T, typename CT> Callback_Gridder_getClosestFreePointPtr
newCallback_Gridder_getClosestFreePoint(const IceUtil::Handle<T>& instance, void (T::*cb)(const TPoint&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getClosestFreePoint<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 */
template<class T, typename CT> Callback_Gridder_getClosestFreePointPtr
newCallback_Gridder_getClosestFreePoint(T* instance, void (T::*cb)(const TPoint&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getClosestFreePoint<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getDimensions.
 */
template<class T>
class CallbackNC_Gridder_getDimensions : public Callback_Gridder_getDimensions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const TDimensions&);

    CallbackNC_Gridder_getDimensions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        TDimensions ret;
        try
        {
            ret = proxy->end_getDimensions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 */
template<class T> Callback_Gridder_getDimensionsPtr
newCallback_Gridder_getDimensions(const IceUtil::Handle<T>& instance, void (T::*cb)(const TDimensions&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getDimensions<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 */
template<class T> Callback_Gridder_getDimensionsPtr
newCallback_Gridder_getDimensions(T* instance, void (T::*cb)(const TDimensions&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getDimensions<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getDimensions.
 */
template<class T, typename CT>
class Callback_Gridder_getDimensions : public Callback_Gridder_getDimensions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const TDimensions&, const CT&);

    Callback_Gridder_getDimensions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        TDimensions ret;
        try
        {
            ret = proxy->end_getDimensions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 */
template<class T, typename CT> Callback_Gridder_getDimensionsPtr
newCallback_Gridder_getDimensions(const IceUtil::Handle<T>& instance, void (T::*cb)(const TDimensions&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getDimensions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 */
template<class T, typename CT> Callback_Gridder_getDimensionsPtr
newCallback_Gridder_getDimensions(T* instance, void (T::*cb)(const TDimensions&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getDimensions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getMap.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getMap.
 */
template<class T>
class CallbackNC_Gridder_getMap : public Callback_Gridder_getMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Map&);

    CallbackNC_Gridder_getMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Map ret;
        try
        {
            ret = proxy->end_getMap(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getMap.
 */
template<class T> Callback_Gridder_getMapPtr
newCallback_Gridder_getMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const Map&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getMap<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getMap.
 */
template<class T> Callback_Gridder_getMapPtr
newCallback_Gridder_getMap(T* instance, void (T::*cb)(const Map&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getMap<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getMap.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getMap.
 */
template<class T, typename CT>
class Callback_Gridder_getMap : public Callback_Gridder_getMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Map&, const CT&);

    Callback_Gridder_getMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Map ret;
        try
        {
            ret = proxy->end_getMap(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getMap.
 */
template<class T, typename CT> Callback_Gridder_getMapPtr
newCallback_Gridder_getMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const Map&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getMap<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getMap.
 */
template<class T, typename CT> Callback_Gridder_getMapPtr
newCallback_Gridder_getMap(T* instance, void (T::*cb)(const Map&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getMap<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getPaths.
 */
template<class T>
class CallbackNC_Gridder_getPaths : public Callback_Gridder_getPaths_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Result&);

    CallbackNC_Gridder_getPaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Result ret;
        try
        {
            ret = proxy->end_getPaths(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 */
template<class T> Callback_Gridder_getPathsPtr
newCallback_Gridder_getPaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const Result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getPaths<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 */
template<class T> Callback_Gridder_getPathsPtr
newCallback_Gridder_getPaths(T* instance, void (T::*cb)(const Result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getPaths<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getPaths.
 */
template<class T, typename CT>
class Callback_Gridder_getPaths : public Callback_Gridder_getPaths_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Result&, const CT&);

    Callback_Gridder_getPaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Result ret;
        try
        {
            ret = proxy->end_getPaths(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 */
template<class T, typename CT> Callback_Gridder_getPathsPtr
newCallback_Gridder_getPaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const Result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getPaths<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 */
template<class T, typename CT> Callback_Gridder_getPathsPtr
newCallback_Gridder_getPaths(T* instance, void (T::*cb)(const Result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getPaths<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setGridDimensions.
 */
template<class T>
class CallbackNC_Gridder_setGridDimensions : public Callback_Gridder_setGridDimensions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_setGridDimensions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setGridDimensions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 */
template<class T> Callback_Gridder_setGridDimensionsPtr
newCallback_Gridder_setGridDimensions(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setGridDimensions<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 */
template<class T> Callback_Gridder_setGridDimensionsPtr
newCallback_Gridder_setGridDimensions(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setGridDimensions<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setGridDimensions.
 */
template<class T, typename CT>
class Callback_Gridder_setGridDimensions : public Callback_Gridder_setGridDimensions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_setGridDimensions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setGridDimensions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 */
template<class T, typename CT> Callback_Gridder_setGridDimensionsPtr
newCallback_Gridder_setGridDimensions(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setGridDimensions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 */
template<class T, typename CT> Callback_Gridder_setGridDimensionsPtr
newCallback_Gridder_setGridDimensions(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setGridDimensions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setLocationAndGetPath.
 */
template<class T>
class CallbackNC_Gridder_setLocationAndGetPath : public Callback_Gridder_setLocationAndGetPath_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Result&);

    CallbackNC_Gridder_setLocationAndGetPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Result ret;
        try
        {
            ret = proxy->end_setLocationAndGetPath(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 */
template<class T> Callback_Gridder_setLocationAndGetPathPtr
newCallback_Gridder_setLocationAndGetPath(const IceUtil::Handle<T>& instance, void (T::*cb)(const Result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setLocationAndGetPath<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 */
template<class T> Callback_Gridder_setLocationAndGetPathPtr
newCallback_Gridder_setLocationAndGetPath(T* instance, void (T::*cb)(const Result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setLocationAndGetPath<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setLocationAndGetPath.
 */
template<class T, typename CT>
class Callback_Gridder_setLocationAndGetPath : public Callback_Gridder_setLocationAndGetPath_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Result&, const CT&);

    Callback_Gridder_setLocationAndGetPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Result ret;
        try
        {
            ret = proxy->end_setLocationAndGetPath(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 */
template<class T, typename CT> Callback_Gridder_setLocationAndGetPathPtr
newCallback_Gridder_setLocationAndGetPath(const IceUtil::Handle<T>& instance, void (T::*cb)(const Result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setLocationAndGetPath<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 */
template<class T, typename CT> Callback_Gridder_setLocationAndGetPathPtr
newCallback_Gridder_setLocationAndGetPath(T* instance, void (T::*cb)(const Result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setLocationAndGetPath<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
