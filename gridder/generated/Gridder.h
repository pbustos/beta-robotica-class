//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `Gridder.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __Gridder_h__
#define __Gridder_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace RoboCompGridder
{

class Gridder;
class GridderPrx;

}

namespace RoboCompGridder
{

struct TPoint
{
    float x;
    float y;
    float radius;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const float&> ice_tuple() const
    {
        return std::tie(x, y, radius);
    }
};

using TPointVector = ::std::vector<TPoint>;

using TPath = ::std::vector<TPoint>;

using TPaths = ::std::vector<TPath>;

struct TDimensions
{
    float left;
    float top;
    float width;
    float height;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const float&, const float&> ice_tuple() const
    {
        return std::tie(left, top, width, height);
    }
};

struct Result
{
    ::RoboCompGridder::TPaths paths;
    long long int timestamp;
    ::std::string errorMsg;
    bool valid;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::RoboCompGridder::TPaths&, const long long int&, const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(paths, timestamp, errorMsg, valid);
    }
};

struct TCell
{
    int x;
    int y;
    ::Ice::Byte cost;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const ::Ice::Byte&> ice_tuple() const
    {
        return std::tie(x, y, cost);
    }
};

using TCellVector = ::std::vector<TCell>;

struct Map
{
    int tileSize;
    ::RoboCompGridder::TCellVector cells;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::RoboCompGridder::TCellVector&> ice_tuple() const
    {
        return std::tie(tileSize, cells);
    }
};

using Covariance = ::std::vector<float>;

struct Pose
{
    float x;
    float y;
    float theta;
    ::RoboCompGridder::Covariance cov;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const float&, const ::RoboCompGridder::Covariance&> ice_tuple() const
    {
        return std::tie(x, y, theta, cov);
    }
};

enum class NavigationState : unsigned char
{
    IDLE,
    NAVIGATING,
    PAUSED,
    REACHED,
    BLOCKED,
    ERROR
};

struct NavigationOptions
{
    float maxSpeed;
    float safetyFactor;
    bool useEsdf;
    bool allowReplan;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const float&, const float&, const bool&, const bool&> ice_tuple() const
    {
        return std::tie(maxSpeed, safetyFactor, useEsdf, allowReplan);
    }
};

struct NavigationStatus
{
    ::RoboCompGridder::NavigationState state;
    ::RoboCompGridder::TPoint currentTarget;
    ::RoboCompGridder::TPoint currentPosition;
    float currentOrientation;
    float distanceToTarget;
    float estimatedTime;
    float currentSpeed;
    int pathWaypointsRemaining;
    ::std::string statusMessage;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::RoboCompGridder::NavigationState&, const ::RoboCompGridder::TPoint&, const ::RoboCompGridder::TPoint&, const float&, const float&, const float&, const float&, const int&, const ::std::string&> ice_tuple() const
    {
        return std::tie(state, currentTarget, currentPosition, currentOrientation, distanceToTarget, estimatedTime, currentSpeed, pathWaypointsRemaining, statusMessage);
    }
};

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace RoboCompGridder
{

class Gridder : public virtual ::Ice::Object
{
public:

    using ProxyType = GridderPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool IsPathBlocked(TPath path, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_IsPathBlocked(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool LineOfSightToTarget(TPoint source, TPoint target, float robotRadius, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_LineOfSightToTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void cancelNavigation(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_cancelNavigation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TPoint getClosestFreePoint(TPoint source, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getClosestFreePoint(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TDimensions getDimensions(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getDimensions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual float getDistanceToTarget(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getDistanceToTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual float getEstimatedTimeToTarget(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getEstimatedTimeToTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Map getMap(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getMap(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual NavigationState getNavigationState(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getNavigationState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual NavigationStatus getNavigationStatus(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getNavigationStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Result getPaths(TPoint source, TPoint target, int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, float safetyFactor, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getPaths(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Pose getPose(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getPose(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TPoint getTarget(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool hasReachedTarget(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_hasReachedTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool replanPath(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_replanPath(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool resumeNavigation(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_resumeNavigation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setGridDimensions(TDimensions dimensions, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setGridDimensions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Result setLocationAndGetPath(TPoint source, TPoint target, TPointVector freePoints, TPointVector obstaclePoints, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setLocationAndGetPath(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setTarget(TPoint target, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setTargetWithOptions(TPoint target, NavigationOptions options, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_setTargetWithOptions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool startNavigation(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_startNavigation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void stopNavigation(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_stopNavigation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace RoboCompGridder
{

class GridderPrx : public virtual ::Ice::Proxy<GridderPrx, ::Ice::ObjectPrx>
{
public:

    bool IsPathBlocked(const TPath& path, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_IsPathBlocked, path, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto IsPathBlockedAsync(const TPath& path, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_IsPathBlocked, path, context);
    }

    ::std::function<void()>
    IsPathBlockedAsync(const TPath& path,
                       ::std::function<void(bool)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_IsPathBlocked, path, context);
    }

    /// \cond INTERNAL
    void _iceI_IsPathBlocked(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const TPath&, const ::Ice::Context&);
    /// \endcond

    bool LineOfSightToTarget(const TPoint& source, const TPoint& target, float robotRadius, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_LineOfSightToTarget, source, target, robotRadius, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto LineOfSightToTargetAsync(const TPoint& source, const TPoint& target, float robotRadius, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_LineOfSightToTarget, source, target, robotRadius, context);
    }

    ::std::function<void()>
    LineOfSightToTargetAsync(const TPoint& source, const TPoint& target, float robotRadius,
                             ::std::function<void(bool)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_LineOfSightToTarget, source, target, robotRadius, context);
    }

    /// \cond INTERNAL
    void _iceI_LineOfSightToTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const TPoint&, const TPoint&, float, const ::Ice::Context&);
    /// \endcond

    void cancelNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &GridderPrx::_iceI_cancelNavigation, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto cancelNavigationAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &GridderPrx::_iceI_cancelNavigation, context);
    }

    ::std::function<void()>
    cancelNavigationAsync(::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_cancelNavigation, context);
    }

    /// \cond INTERNAL
    void _iceI_cancelNavigation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    TPoint getClosestFreePoint(const TPoint& source, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::TPoint>(true, this, &GridderPrx::_iceI_getClosestFreePoint, source, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getClosestFreePointAsync(const TPoint& source, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::TPoint>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::TPoint, P>(false, this, &GridderPrx::_iceI_getClosestFreePoint, source, context);
    }

    ::std::function<void()>
    getClosestFreePointAsync(const TPoint& source,
                             ::std::function<void(::RoboCompGridder::TPoint)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::TPoint>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getClosestFreePoint, source, context);
    }

    /// \cond INTERNAL
    void _iceI_getClosestFreePoint(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::TPoint>>&, const TPoint&, const ::Ice::Context&);
    /// \endcond

    TDimensions getDimensions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::TDimensions>(true, this, &GridderPrx::_iceI_getDimensions, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getDimensionsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::TDimensions>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::TDimensions, P>(false, this, &GridderPrx::_iceI_getDimensions, context);
    }

    ::std::function<void()>
    getDimensionsAsync(::std::function<void(::RoboCompGridder::TDimensions)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::TDimensions>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getDimensions, context);
    }

    /// \cond INTERNAL
    void _iceI_getDimensions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::TDimensions>>&, const ::Ice::Context&);
    /// \endcond

    float getDistanceToTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<float>(true, this, &GridderPrx::_iceI_getDistanceToTarget, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getDistanceToTargetAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<float>>().get_future())
    {
        return _makePromiseOutgoing<float, P>(false, this, &GridderPrx::_iceI_getDistanceToTarget, context);
    }

    ::std::function<void()>
    getDistanceToTargetAsync(::std::function<void(float)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<float>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getDistanceToTarget, context);
    }

    /// \cond INTERNAL
    void _iceI_getDistanceToTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<float>>&, const ::Ice::Context&);
    /// \endcond

    float getEstimatedTimeToTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<float>(true, this, &GridderPrx::_iceI_getEstimatedTimeToTarget, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getEstimatedTimeToTargetAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<float>>().get_future())
    {
        return _makePromiseOutgoing<float, P>(false, this, &GridderPrx::_iceI_getEstimatedTimeToTarget, context);
    }

    ::std::function<void()>
    getEstimatedTimeToTargetAsync(::std::function<void(float)> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<float>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getEstimatedTimeToTarget, context);
    }

    /// \cond INTERNAL
    void _iceI_getEstimatedTimeToTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<float>>&, const ::Ice::Context&);
    /// \endcond

    Map getMap(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::Map>(true, this, &GridderPrx::_iceI_getMap, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getMapAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::Map>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::Map, P>(false, this, &GridderPrx::_iceI_getMap, context);
    }

    ::std::function<void()>
    getMapAsync(::std::function<void(::RoboCompGridder::Map)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::Map>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getMap, context);
    }

    /// \cond INTERNAL
    void _iceI_getMap(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::Map>>&, const ::Ice::Context&);
    /// \endcond

    NavigationState getNavigationState(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::NavigationState>(true, this, &GridderPrx::_iceI_getNavigationState, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNavigationStateAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::NavigationState>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::NavigationState, P>(false, this, &GridderPrx::_iceI_getNavigationState, context);
    }

    ::std::function<void()>
    getNavigationStateAsync(::std::function<void(::RoboCompGridder::NavigationState)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::NavigationState>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getNavigationState, context);
    }

    /// \cond INTERNAL
    void _iceI_getNavigationState(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::NavigationState>>&, const ::Ice::Context&);
    /// \endcond

    NavigationStatus getNavigationStatus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::NavigationStatus>(true, this, &GridderPrx::_iceI_getNavigationStatus, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNavigationStatusAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::NavigationStatus>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::NavigationStatus, P>(false, this, &GridderPrx::_iceI_getNavigationStatus, context);
    }

    ::std::function<void()>
    getNavigationStatusAsync(::std::function<void(::RoboCompGridder::NavigationStatus)> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::NavigationStatus>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getNavigationStatus, context);
    }

    /// \cond INTERNAL
    void _iceI_getNavigationStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::NavigationStatus>>&, const ::Ice::Context&);
    /// \endcond

    Result getPaths(const TPoint& source, const TPoint& target, int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, float safetyFactor, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::Result>(true, this, &GridderPrx::_iceI_getPaths, source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getPathsAsync(const TPoint& source, const TPoint& target, int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, float safetyFactor, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::Result>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::Result, P>(false, this, &GridderPrx::_iceI_getPaths, source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context);
    }

    ::std::function<void()>
    getPathsAsync(const TPoint& source, const TPoint& target, int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, float safetyFactor,
                  ::std::function<void(::RoboCompGridder::Result)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::Result>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getPaths, source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context);
    }

    /// \cond INTERNAL
    void _iceI_getPaths(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::Result>>&, const TPoint&, const TPoint&, int, bool, bool, float, const ::Ice::Context&);
    /// \endcond

    Pose getPose(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::Pose>(true, this, &GridderPrx::_iceI_getPose, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getPoseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::Pose>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::Pose, P>(false, this, &GridderPrx::_iceI_getPose, context);
    }

    ::std::function<void()>
    getPoseAsync(::std::function<void(::RoboCompGridder::Pose)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::Pose>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getPose, context);
    }

    /// \cond INTERNAL
    void _iceI_getPose(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::Pose>>&, const ::Ice::Context&);
    /// \endcond

    TPoint getTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::TPoint>(true, this, &GridderPrx::_iceI_getTarget, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getTargetAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::TPoint>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::TPoint, P>(false, this, &GridderPrx::_iceI_getTarget, context);
    }

    ::std::function<void()>
    getTargetAsync(::std::function<void(::RoboCompGridder::TPoint)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::TPoint>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_getTarget, context);
    }

    /// \cond INTERNAL
    void _iceI_getTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::TPoint>>&, const ::Ice::Context&);
    /// \endcond

    bool hasReachedTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_hasReachedTarget, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto hasReachedTargetAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_hasReachedTarget, context);
    }

    ::std::function<void()>
    hasReachedTargetAsync(::std::function<void(bool)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_hasReachedTarget, context);
    }

    /// \cond INTERNAL
    void _iceI_hasReachedTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool replanPath(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_replanPath, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto replanPathAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_replanPath, context);
    }

    ::std::function<void()>
    replanPathAsync(::std::function<void(bool)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_replanPath, context);
    }

    /// \cond INTERNAL
    void _iceI_replanPath(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool resumeNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_resumeNavigation, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto resumeNavigationAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_resumeNavigation, context);
    }

    ::std::function<void()>
    resumeNavigationAsync(::std::function<void(bool)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_resumeNavigation, context);
    }

    /// \cond INTERNAL
    void _iceI_resumeNavigation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool setGridDimensions(const TDimensions& dimensions, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_setGridDimensions, dimensions, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setGridDimensionsAsync(const TDimensions& dimensions, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_setGridDimensions, dimensions, context);
    }

    ::std::function<void()>
    setGridDimensionsAsync(const TDimensions& dimensions,
                           ::std::function<void(bool)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_setGridDimensions, dimensions, context);
    }

    /// \cond INTERNAL
    void _iceI_setGridDimensions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const TDimensions&, const ::Ice::Context&);
    /// \endcond

    Result setLocationAndGetPath(const TPoint& source, const TPoint& target, const TPointVector& freePoints, const TPointVector& obstaclePoints, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::RoboCompGridder::Result>(true, this, &GridderPrx::_iceI_setLocationAndGetPath, source, target, freePoints, obstaclePoints, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setLocationAndGetPathAsync(const TPoint& source, const TPoint& target, const TPointVector& freePoints, const TPointVector& obstaclePoints, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::RoboCompGridder::Result>>().get_future())
    {
        return _makePromiseOutgoing<::RoboCompGridder::Result, P>(false, this, &GridderPrx::_iceI_setLocationAndGetPath, source, target, freePoints, obstaclePoints, context);
    }

    ::std::function<void()>
    setLocationAndGetPathAsync(const TPoint& source, const TPoint& target, const TPointVector& freePoints, const TPointVector& obstaclePoints,
                               ::std::function<void(::RoboCompGridder::Result)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::RoboCompGridder::Result>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_setLocationAndGetPath, source, target, freePoints, obstaclePoints, context);
    }

    /// \cond INTERNAL
    void _iceI_setLocationAndGetPath(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::RoboCompGridder::Result>>&, const TPoint&, const TPoint&, const TPointVector&, const TPointVector&, const ::Ice::Context&);
    /// \endcond

    bool setTarget(const TPoint& target, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_setTarget, target, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setTargetAsync(const TPoint& target, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_setTarget, target, context);
    }

    ::std::function<void()>
    setTargetAsync(const TPoint& target,
                   ::std::function<void(bool)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_setTarget, target, context);
    }

    /// \cond INTERNAL
    void _iceI_setTarget(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const TPoint&, const ::Ice::Context&);
    /// \endcond

    bool setTargetWithOptions(const TPoint& target, const NavigationOptions& options, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_setTargetWithOptions, target, options, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto setTargetWithOptionsAsync(const TPoint& target, const NavigationOptions& options, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_setTargetWithOptions, target, options, context);
    }

    ::std::function<void()>
    setTargetWithOptionsAsync(const TPoint& target, const NavigationOptions& options,
                              ::std::function<void(bool)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_setTargetWithOptions, target, options, context);
    }

    /// \cond INTERNAL
    void _iceI_setTargetWithOptions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const TPoint&, const NavigationOptions&, const ::Ice::Context&);
    /// \endcond

    bool startNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &GridderPrx::_iceI_startNavigation, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto startNavigationAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &GridderPrx::_iceI_startNavigation, context);
    }

    ::std::function<void()>
    startNavigationAsync(::std::function<void(bool)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_startNavigation, context);
    }

    /// \cond INTERNAL
    void _iceI_startNavigation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    void stopNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &GridderPrx::_iceI_stopNavigation, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto stopNavigationAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &GridderPrx::_iceI_stopNavigation, context);
    }

    ::std::function<void()>
    stopNavigationAsync(::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &RoboCompGridder::GridderPrx::_iceI_stopNavigation, context);
    }

    /// \cond INTERNAL
    void _iceI_stopNavigation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    GridderPrx() = default;
    friend ::std::shared_ptr<GridderPrx> IceInternal::createProxy<GridderPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::RoboCompGridder::TPoint>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompGridder::TPoint, S>
{
    static void read(S* istr, ::RoboCompGridder::TPoint& v)
    {
        istr->readAll(v.x, v.y, v.radius);
    }
};

template<>
struct StreamableTraits<::RoboCompGridder::TDimensions>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompGridder::TDimensions, S>
{
    static void read(S* istr, ::RoboCompGridder::TDimensions& v)
    {
        istr->readAll(v.left, v.top, v.width, v.height);
    }
};

template<>
struct StreamableTraits<::RoboCompGridder::Result>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompGridder::Result, S>
{
    static void read(S* istr, ::RoboCompGridder::Result& v)
    {
        istr->readAll(v.paths, v.timestamp, v.errorMsg, v.valid);
    }
};

template<>
struct StreamableTraits<::RoboCompGridder::TCell>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompGridder::TCell, S>
{
    static void read(S* istr, ::RoboCompGridder::TCell& v)
    {
        istr->readAll(v.x, v.y, v.cost);
    }
};

template<>
struct StreamableTraits<::RoboCompGridder::Map>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompGridder::Map, S>
{
    static void read(S* istr, ::RoboCompGridder::Map& v)
    {
        istr->readAll(v.tileSize, v.cells);
    }
};

template<>
struct StreamableTraits<::RoboCompGridder::Pose>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompGridder::Pose, S>
{
    static void read(S* istr, ::RoboCompGridder::Pose& v)
    {
        istr->readAll(v.x, v.y, v.theta, v.cov);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::NavigationState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 5;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::RoboCompGridder::NavigationOptions>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::RoboCompGridder::NavigationOptions, S>
{
    static void read(S* istr, ::RoboCompGridder::NavigationOptions& v)
    {
        istr->readAll(v.maxSpeed, v.safetyFactor, v.useEsdf, v.allowReplan);
    }
};

template<>
struct StreamableTraits<::RoboCompGridder::NavigationStatus>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 46;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::RoboCompGridder::NavigationStatus, S>
{
    static void read(S* istr, ::RoboCompGridder::NavigationStatus& v)
    {
        istr->readAll(v.state, v.currentTarget, v.currentPosition, v.currentOrientation, v.distanceToTarget, v.estimatedTime, v.currentSpeed, v.pathWaypointsRemaining, v.statusMessage);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace RoboCompGridder
{

using GridderPtr = ::std::shared_ptr<Gridder>;
using GridderPrxPtr = ::std::shared_ptr<GridderPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace RoboCompGridder
{

class Gridder;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Gridder>&);
::IceProxy::Ice::Object* upCast(Gridder*);
/// \endcond

}

}

namespace RoboCompGridder
{

class Gridder;
/// \cond INTERNAL
::Ice::Object* upCast(Gridder*);
/// \endcond
typedef ::IceInternal::Handle< Gridder> GridderPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::RoboCompGridder::Gridder> GridderPrx;
typedef GridderPrx GridderPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(GridderPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace RoboCompGridder
{

struct TPoint
{
    ::Ice::Float x;
    ::Ice::Float y;
    ::Ice::Float radius;
};

typedef ::std::vector<TPoint> TPointVector;

typedef ::std::vector<TPoint> TPath;

typedef ::std::vector<TPath> TPaths;

struct TDimensions
{
    ::Ice::Float left;
    ::Ice::Float top;
    ::Ice::Float width;
    ::Ice::Float height;
};

struct Result
{
    ::RoboCompGridder::TPaths paths;
    ::Ice::Long timestamp;
    ::std::string errorMsg;
    bool valid;
};

struct TCell
{
    ::Ice::Int x;
    ::Ice::Int y;
    ::Ice::Byte cost;

    bool operator==(const TCell& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(x != rhs_.x)
        {
            return false;
        }
        if(y != rhs_.y)
        {
            return false;
        }
        if(cost != rhs_.cost)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TCell& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(x < rhs_.x)
        {
            return true;
        }
        else if(rhs_.x < x)
        {
            return false;
        }
        if(y < rhs_.y)
        {
            return true;
        }
        else if(rhs_.y < y)
        {
            return false;
        }
        if(cost < rhs_.cost)
        {
            return true;
        }
        else if(rhs_.cost < cost)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TCell& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const TCell& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const TCell& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const TCell& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<TCell> TCellVector;

struct Map
{
    ::Ice::Int tileSize;
    ::RoboCompGridder::TCellVector cells;
};

typedef ::std::vector< ::Ice::Float> Covariance;

struct Pose
{
    ::Ice::Float x;
    ::Ice::Float y;
    ::Ice::Float theta;
    ::RoboCompGridder::Covariance cov;
};

enum NavigationState
{
    IDLE,
    NAVIGATING,
    PAUSED,
    REACHED,
    BLOCKED,
    ERROR
};

struct NavigationOptions
{
    ::Ice::Float maxSpeed;
    ::Ice::Float safetyFactor;
    bool useEsdf;
    bool allowReplan;
};

struct NavigationStatus
{
    ::RoboCompGridder::NavigationState state;
    ::RoboCompGridder::TPoint currentTarget;
    ::RoboCompGridder::TPoint currentPosition;
    ::Ice::Float currentOrientation;
    ::Ice::Float distanceToTarget;
    ::Ice::Float estimatedTime;
    ::Ice::Float currentSpeed;
    ::Ice::Int pathWaypointsRemaining;
    ::std::string statusMessage;
};

}

namespace RoboCompGridder
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_IsPathBlocked.
 */
class Callback_Gridder_IsPathBlocked_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_IsPathBlocked_Base> Callback_Gridder_IsPathBlockedPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_LineOfSightToTarget.
 */
class Callback_Gridder_LineOfSightToTarget_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_LineOfSightToTarget_Base> Callback_Gridder_LineOfSightToTargetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_cancelNavigation.
 */
class Callback_Gridder_cancelNavigation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_cancelNavigation_Base> Callback_Gridder_cancelNavigationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getClosestFreePoint.
 */
class Callback_Gridder_getClosestFreePoint_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getClosestFreePoint_Base> Callback_Gridder_getClosestFreePointPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getDimensions.
 */
class Callback_Gridder_getDimensions_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getDimensions_Base> Callback_Gridder_getDimensionsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getDistanceToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getDistanceToTarget.
 */
class Callback_Gridder_getDistanceToTarget_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getDistanceToTarget_Base> Callback_Gridder_getDistanceToTargetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getEstimatedTimeToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getEstimatedTimeToTarget.
 */
class Callback_Gridder_getEstimatedTimeToTarget_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getEstimatedTimeToTarget_Base> Callback_Gridder_getEstimatedTimeToTargetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getMap.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getMap.
 */
class Callback_Gridder_getMap_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getMap_Base> Callback_Gridder_getMapPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getNavigationState.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getNavigationState.
 */
class Callback_Gridder_getNavigationState_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getNavigationState_Base> Callback_Gridder_getNavigationStatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getNavigationStatus.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getNavigationStatus.
 */
class Callback_Gridder_getNavigationStatus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getNavigationStatus_Base> Callback_Gridder_getNavigationStatusPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getPaths.
 */
class Callback_Gridder_getPaths_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getPaths_Base> Callback_Gridder_getPathsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getPose.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getPose.
 */
class Callback_Gridder_getPose_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getPose_Base> Callback_Gridder_getPosePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getTarget.
 */
class Callback_Gridder_getTarget_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_getTarget_Base> Callback_Gridder_getTargetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_hasReachedTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_hasReachedTarget.
 */
class Callback_Gridder_hasReachedTarget_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_hasReachedTarget_Base> Callback_Gridder_hasReachedTargetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_replanPath.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_replanPath.
 */
class Callback_Gridder_replanPath_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_replanPath_Base> Callback_Gridder_replanPathPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_resumeNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_resumeNavigation.
 */
class Callback_Gridder_resumeNavigation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_resumeNavigation_Base> Callback_Gridder_resumeNavigationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setGridDimensions.
 */
class Callback_Gridder_setGridDimensions_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_setGridDimensions_Base> Callback_Gridder_setGridDimensionsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setLocationAndGetPath.
 */
class Callback_Gridder_setLocationAndGetPath_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_setLocationAndGetPath_Base> Callback_Gridder_setLocationAndGetPathPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setTarget.
 */
class Callback_Gridder_setTarget_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_setTarget_Base> Callback_Gridder_setTargetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setTargetWithOptions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setTargetWithOptions.
 */
class Callback_Gridder_setTargetWithOptions_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_setTargetWithOptions_Base> Callback_Gridder_setTargetWithOptionsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_startNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_startNavigation.
 */
class Callback_Gridder_startNavigation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_startNavigation_Base> Callback_Gridder_startNavigationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_stopNavigation.
 */
class Callback_Gridder_stopNavigation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Gridder_stopNavigation_Base> Callback_Gridder_stopNavigationPtr;

}

namespace IceProxy
{

namespace RoboCompGridder
{

class Gridder : public virtual ::Ice::Proxy<Gridder, ::IceProxy::Ice::Object>
{
public:

    bool IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_IsPathBlocked(_iceI_begin_IsPathBlocked(path, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_IsPathBlocked(path, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsPathBlocked(path, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsPathBlocked(path, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::RoboCompGridder::Callback_Gridder_IsPathBlockedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsPathBlocked(path, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsPathBlocked(const ::RoboCompGridder::TPath& path, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_IsPathBlockedPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsPathBlocked(path, context, cb, cookie);
    }

    bool end_IsPathBlocked(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_IsPathBlocked(const ::RoboCompGridder::TPath&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_LineOfSightToTarget(_iceI_begin_LineOfSightToTarget(source, target, robotRadius, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_LineOfSightToTarget(source, target, robotRadius, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LineOfSightToTarget(source, target, robotRadius, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LineOfSightToTarget(source, target, robotRadius, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::RoboCompGridder::Callback_Gridder_LineOfSightToTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LineOfSightToTarget(source, target, robotRadius, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Float robotRadius, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_LineOfSightToTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LineOfSightToTarget(source, target, robotRadius, context, cb, cookie);
    }

    bool end_LineOfSightToTarget(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_LineOfSightToTarget(const ::RoboCompGridder::TPoint&, const ::RoboCompGridder::TPoint&, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void cancelNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_cancelNavigation(_iceI_begin_cancelNavigation(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_cancelNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_cancelNavigation(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cancelNavigation(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancelNavigation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancelNavigation(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancelNavigation(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancelNavigation(const ::RoboCompGridder::Callback_Gridder_cancelNavigationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancelNavigation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_cancelNavigation(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_cancelNavigationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_cancelNavigation(context, cb, cookie);
    }

    void end_cancelNavigation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_cancelNavigation(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::TPoint getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getClosestFreePoint(_iceI_begin_getClosestFreePoint(source, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getClosestFreePoint(source, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClosestFreePoint(source, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClosestFreePoint(source, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::Callback_Gridder_getClosestFreePointPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClosestFreePoint(source, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getClosestFreePoint(const ::RoboCompGridder::TPoint& source, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getClosestFreePointPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getClosestFreePoint(source, context, cb, cookie);
    }

    ::RoboCompGridder::TPoint end_getClosestFreePoint(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getClosestFreePoint(const ::RoboCompGridder::TPoint&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::TDimensions getDimensions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getDimensions(_iceI_begin_getDimensions(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getDimensions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getDimensions(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDimensions(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDimensions(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDimensions(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDimensions(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDimensions(const ::RoboCompGridder::Callback_Gridder_getDimensionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDimensions(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDimensions(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getDimensionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDimensions(context, cb, cookie);
    }

    ::RoboCompGridder::TDimensions end_getDimensions(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getDimensions(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Float getDistanceToTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getDistanceToTarget(_iceI_begin_getDistanceToTarget(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getDistanceToTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getDistanceToTarget(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getDistanceToTarget(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDistanceToTarget(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDistanceToTarget(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDistanceToTarget(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDistanceToTarget(const ::RoboCompGridder::Callback_Gridder_getDistanceToTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDistanceToTarget(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getDistanceToTarget(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getDistanceToTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getDistanceToTarget(context, cb, cookie);
    }

    ::Ice::Float end_getDistanceToTarget(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getDistanceToTarget(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Float getEstimatedTimeToTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getEstimatedTimeToTarget(_iceI_begin_getEstimatedTimeToTarget(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getEstimatedTimeToTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getEstimatedTimeToTarget(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getEstimatedTimeToTarget(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEstimatedTimeToTarget(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEstimatedTimeToTarget(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEstimatedTimeToTarget(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEstimatedTimeToTarget(const ::RoboCompGridder::Callback_Gridder_getEstimatedTimeToTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEstimatedTimeToTarget(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getEstimatedTimeToTarget(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getEstimatedTimeToTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getEstimatedTimeToTarget(context, cb, cookie);
    }

    ::Ice::Float end_getEstimatedTimeToTarget(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getEstimatedTimeToTarget(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::Map getMap(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getMap(_iceI_begin_getMap(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getMap(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getMap(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getMap(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMap(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMap(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMap(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMap(const ::RoboCompGridder::Callback_Gridder_getMapPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMap(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getMap(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getMapPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getMap(context, cb, cookie);
    }

    ::RoboCompGridder::Map end_getMap(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getMap(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::NavigationState getNavigationState(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getNavigationState(_iceI_begin_getNavigationState(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getNavigationState(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getNavigationState(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNavigationState(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavigationState(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNavigationState(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavigationState(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNavigationState(const ::RoboCompGridder::Callback_Gridder_getNavigationStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavigationState(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNavigationState(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getNavigationStatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavigationState(context, cb, cookie);
    }

    ::RoboCompGridder::NavigationState end_getNavigationState(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getNavigationState(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::NavigationStatus getNavigationStatus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getNavigationStatus(_iceI_begin_getNavigationStatus(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getNavigationStatus(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getNavigationStatus(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNavigationStatus(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavigationStatus(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNavigationStatus(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavigationStatus(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNavigationStatus(const ::RoboCompGridder::Callback_Gridder_getNavigationStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavigationStatus(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNavigationStatus(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getNavigationStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavigationStatus(context, cb, cookie);
    }

    ::RoboCompGridder::NavigationStatus end_getNavigationStatus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getNavigationStatus(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::Result getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getPaths(_iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::RoboCompGridder::Callback_Gridder_getPathsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPaths(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getPathsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPaths(source, target, maxPaths, tryClosestFreePoint, targetIsHuman, safetyFactor, context, cb, cookie);
    }

    ::RoboCompGridder::Result end_getPaths(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getPaths(const ::RoboCompGridder::TPoint&, const ::RoboCompGridder::TPoint&, ::Ice::Int, bool, bool, ::Ice::Float, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::Pose getPose(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getPose(_iceI_begin_getPose(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getPose(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPose(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPose(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::RoboCompGridder::Callback_Gridder_getPosePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPose(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getPose(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getPosePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getPose(context, cb, cookie);
    }

    ::RoboCompGridder::Pose end_getPose(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getPose(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::TPoint getTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getTarget(_iceI_begin_getTarget(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getTarget(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTarget(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTarget(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTarget(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTarget(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTarget(const ::RoboCompGridder::Callback_Gridder_getTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTarget(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTarget(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_getTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTarget(context, cb, cookie);
    }

    ::RoboCompGridder::TPoint end_getTarget(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getTarget(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool hasReachedTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_hasReachedTarget(_iceI_begin_hasReachedTarget(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_hasReachedTarget(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_hasReachedTarget(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_hasReachedTarget(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hasReachedTarget(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hasReachedTarget(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hasReachedTarget(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hasReachedTarget(const ::RoboCompGridder::Callback_Gridder_hasReachedTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hasReachedTarget(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_hasReachedTarget(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_hasReachedTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_hasReachedTarget(context, cb, cookie);
    }

    bool end_hasReachedTarget(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_hasReachedTarget(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool replanPath(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_replanPath(_iceI_begin_replanPath(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_replanPath(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_replanPath(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_replanPath(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_replanPath(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_replanPath(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_replanPath(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_replanPath(const ::RoboCompGridder::Callback_Gridder_replanPathPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_replanPath(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_replanPath(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_replanPathPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_replanPath(context, cb, cookie);
    }

    bool end_replanPath(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_replanPath(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool resumeNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_resumeNavigation(_iceI_begin_resumeNavigation(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_resumeNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_resumeNavigation(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_resumeNavigation(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_resumeNavigation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_resumeNavigation(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_resumeNavigation(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_resumeNavigation(const ::RoboCompGridder::Callback_Gridder_resumeNavigationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_resumeNavigation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_resumeNavigation(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_resumeNavigationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_resumeNavigation(context, cb, cookie);
    }

    bool end_resumeNavigation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_resumeNavigation(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setGridDimensions(_iceI_begin_setGridDimensions(dimensions, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setGridDimensions(dimensions, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setGridDimensions(dimensions, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setGridDimensions(dimensions, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::RoboCompGridder::Callback_Gridder_setGridDimensionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setGridDimensions(dimensions, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setGridDimensions(const ::RoboCompGridder::TDimensions& dimensions, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_setGridDimensionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setGridDimensions(dimensions, context, cb, cookie);
    }

    bool end_setGridDimensions(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setGridDimensions(const ::RoboCompGridder::TDimensions&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::RoboCompGridder::Result setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setLocationAndGetPath(_iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::RoboCompGridder::Callback_Gridder_setLocationAndGetPathPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint& source, const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::TPointVector& freePoints, const ::RoboCompGridder::TPointVector& obstaclePoints, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_setLocationAndGetPathPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setLocationAndGetPath(source, target, freePoints, obstaclePoints, context, cb, cookie);
    }

    ::RoboCompGridder::Result end_setLocationAndGetPath(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setLocationAndGetPath(const ::RoboCompGridder::TPoint&, const ::RoboCompGridder::TPoint&, const ::RoboCompGridder::TPointVector&, const ::RoboCompGridder::TPointVector&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool setTarget(const ::RoboCompGridder::TPoint& target, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setTarget(_iceI_begin_setTarget(target, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setTarget(const ::RoboCompGridder::TPoint& target, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setTarget(target, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTarget(const ::RoboCompGridder::TPoint& target, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTarget(target, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTarget(const ::RoboCompGridder::TPoint& target, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTarget(target, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTarget(const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::Callback_Gridder_setTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTarget(target, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTarget(const ::RoboCompGridder::TPoint& target, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_setTargetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTarget(target, context, cb, cookie);
    }

    bool end_setTarget(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setTarget(const ::RoboCompGridder::TPoint&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool setTargetWithOptions(const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::NavigationOptions& options, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_setTargetWithOptions(_iceI_begin_setTargetWithOptions(target, options, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_setTargetWithOptions(const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::NavigationOptions& options, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_setTargetWithOptions(target, options, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setTargetWithOptions(const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::NavigationOptions& options, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTargetWithOptions(target, options, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTargetWithOptions(const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::NavigationOptions& options, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTargetWithOptions(target, options, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTargetWithOptions(const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::NavigationOptions& options, const ::RoboCompGridder::Callback_Gridder_setTargetWithOptionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTargetWithOptions(target, options, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_setTargetWithOptions(const ::RoboCompGridder::TPoint& target, const ::RoboCompGridder::NavigationOptions& options, const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_setTargetWithOptionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_setTargetWithOptions(target, options, context, cb, cookie);
    }

    bool end_setTargetWithOptions(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_setTargetWithOptions(const ::RoboCompGridder::TPoint&, const ::RoboCompGridder::NavigationOptions&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool startNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_startNavigation(_iceI_begin_startNavigation(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_startNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_startNavigation(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startNavigation(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startNavigation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startNavigation(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startNavigation(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startNavigation(const ::RoboCompGridder::Callback_Gridder_startNavigationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startNavigation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_startNavigation(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_startNavigationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_startNavigation(context, cb, cookie);
    }

    bool end_startNavigation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_startNavigation(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void stopNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_stopNavigation(_iceI_begin_stopNavigation(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_stopNavigation(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_stopNavigation(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_stopNavigation(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_stopNavigation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_stopNavigation(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_stopNavigation(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_stopNavigation(const ::RoboCompGridder::Callback_Gridder_stopNavigationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_stopNavigation(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_stopNavigation(const ::Ice::Context& context, const ::RoboCompGridder::Callback_Gridder_stopNavigationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_stopNavigation(context, cb, cookie);
    }

    void end_stopNavigation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_stopNavigation(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace RoboCompGridder
{

class Gridder : public virtual ::Ice::Object
{
public:

    typedef GridderPrx ProxyType;
    typedef GridderPtr PointerType;

    virtual ~Gridder();

#ifdef ICE_CPP11_COMPILER
    Gridder() = default;
    Gridder(const Gridder&) = default;
    Gridder& operator=(const Gridder&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool IsPathBlocked(const TPath& path, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_IsPathBlocked(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool LineOfSightToTarget(const TPoint& source, const TPoint& target, ::Ice::Float robotRadius, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_LineOfSightToTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void cancelNavigation(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_cancelNavigation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TPoint getClosestFreePoint(const TPoint& source, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getClosestFreePoint(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TDimensions getDimensions(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getDimensions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Float getDistanceToTarget(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getDistanceToTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Float getEstimatedTimeToTarget(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getEstimatedTimeToTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Map getMap(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getMap(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual NavigationState getNavigationState(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getNavigationState(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual NavigationStatus getNavigationStatus(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getNavigationStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Result getPaths(const TPoint& source, const TPoint& target, ::Ice::Int maxPaths, bool tryClosestFreePoint, bool targetIsHuman, ::Ice::Float safetyFactor, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getPaths(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Pose getPose(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getPose(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TPoint getTarget(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool hasReachedTarget(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_hasReachedTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool replanPath(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_replanPath(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool resumeNavigation(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_resumeNavigation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setGridDimensions(const TDimensions& dimensions, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setGridDimensions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual Result setLocationAndGetPath(const TPoint& source, const TPoint& target, const TPointVector& freePoints, const TPointVector& obstaclePoints, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setLocationAndGetPath(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setTarget(const TPoint& target, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setTarget(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool setTargetWithOptions(const TPoint& target, const NavigationOptions& options, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_setTargetWithOptions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool startNavigation(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_startNavigation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void stopNavigation(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_stopNavigation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Gridder& lhs, const Gridder& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Gridder& lhs, const Gridder& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::RoboCompGridder::TPoint>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 12;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::TPoint, S>
{
    static void write(S* ostr, const ::RoboCompGridder::TPoint& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.radius);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::TPoint, S>
{
    static void read(S* istr, ::RoboCompGridder::TPoint& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.radius);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::TDimensions>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::TDimensions, S>
{
    static void write(S* ostr, const ::RoboCompGridder::TDimensions& v)
    {
        ostr->write(v.left);
        ostr->write(v.top);
        ostr->write(v.width);
        ostr->write(v.height);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::TDimensions, S>
{
    static void read(S* istr, ::RoboCompGridder::TDimensions& v)
    {
        istr->read(v.left);
        istr->read(v.top);
        istr->read(v.width);
        istr->read(v.height);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::Result>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::Result, S>
{
    static void write(S* ostr, const ::RoboCompGridder::Result& v)
    {
        ostr->write(v.paths);
        ostr->write(v.timestamp);
        ostr->write(v.errorMsg);
        ostr->write(v.valid);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::Result, S>
{
    static void read(S* istr, ::RoboCompGridder::Result& v)
    {
        istr->read(v.paths);
        istr->read(v.timestamp);
        istr->read(v.errorMsg);
        istr->read(v.valid);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::TCell>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::TCell, S>
{
    static void write(S* ostr, const ::RoboCompGridder::TCell& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.cost);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::TCell, S>
{
    static void read(S* istr, ::RoboCompGridder::TCell& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.cost);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::Map>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::Map, S>
{
    static void write(S* ostr, const ::RoboCompGridder::Map& v)
    {
        ostr->write(v.tileSize);
        ostr->write(v.cells);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::Map, S>
{
    static void read(S* istr, ::RoboCompGridder::Map& v)
    {
        istr->read(v.tileSize);
        istr->read(v.cells);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::Pose>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::Pose, S>
{
    static void write(S* ostr, const ::RoboCompGridder::Pose& v)
    {
        ostr->write(v.x);
        ostr->write(v.y);
        ostr->write(v.theta);
        ostr->write(v.cov);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::Pose, S>
{
    static void read(S* istr, ::RoboCompGridder::Pose& v)
    {
        istr->read(v.x);
        istr->read(v.y);
        istr->read(v.theta);
        istr->read(v.cov);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::NavigationState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 5;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::RoboCompGridder::NavigationOptions>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::NavigationOptions, S>
{
    static void write(S* ostr, const ::RoboCompGridder::NavigationOptions& v)
    {
        ostr->write(v.maxSpeed);
        ostr->write(v.safetyFactor);
        ostr->write(v.useEsdf);
        ostr->write(v.allowReplan);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::NavigationOptions, S>
{
    static void read(S* istr, ::RoboCompGridder::NavigationOptions& v)
    {
        istr->read(v.maxSpeed);
        istr->read(v.safetyFactor);
        istr->read(v.useEsdf);
        istr->read(v.allowReplan);
    }
};

template<>
struct StreamableTraits< ::RoboCompGridder::NavigationStatus>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 46;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::RoboCompGridder::NavigationStatus, S>
{
    static void write(S* ostr, const ::RoboCompGridder::NavigationStatus& v)
    {
        ostr->write(v.state);
        ostr->write(v.currentTarget);
        ostr->write(v.currentPosition);
        ostr->write(v.currentOrientation);
        ostr->write(v.distanceToTarget);
        ostr->write(v.estimatedTime);
        ostr->write(v.currentSpeed);
        ostr->write(v.pathWaypointsRemaining);
        ostr->write(v.statusMessage);
    }
};

template<typename S>
struct StreamReader< ::RoboCompGridder::NavigationStatus, S>
{
    static void read(S* istr, ::RoboCompGridder::NavigationStatus& v)
    {
        istr->read(v.state);
        istr->read(v.currentTarget);
        istr->read(v.currentPosition);
        istr->read(v.currentOrientation);
        istr->read(v.distanceToTarget);
        istr->read(v.estimatedTime);
        istr->read(v.currentSpeed);
        istr->read(v.pathWaypointsRemaining);
        istr->read(v.statusMessage);
    }
};

}
/// \endcond

namespace RoboCompGridder
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_IsPathBlocked.
 */
template<class T>
class CallbackNC_Gridder_IsPathBlocked : public Callback_Gridder_IsPathBlocked_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_IsPathBlocked(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_IsPathBlocked(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 */
template<class T> Callback_Gridder_IsPathBlockedPtr
newCallback_Gridder_IsPathBlocked(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_IsPathBlocked<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 */
template<class T> Callback_Gridder_IsPathBlockedPtr
newCallback_Gridder_IsPathBlocked(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_IsPathBlocked<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_IsPathBlocked.
 */
template<class T, typename CT>
class Callback_Gridder_IsPathBlocked : public Callback_Gridder_IsPathBlocked_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_IsPathBlocked(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_IsPathBlocked(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 */
template<class T, typename CT> Callback_Gridder_IsPathBlockedPtr
newCallback_Gridder_IsPathBlocked(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_IsPathBlocked<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_IsPathBlocked.
 */
template<class T, typename CT> Callback_Gridder_IsPathBlockedPtr
newCallback_Gridder_IsPathBlocked(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_IsPathBlocked<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_LineOfSightToTarget.
 */
template<class T>
class CallbackNC_Gridder_LineOfSightToTarget : public Callback_Gridder_LineOfSightToTarget_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_LineOfSightToTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_LineOfSightToTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 */
template<class T> Callback_Gridder_LineOfSightToTargetPtr
newCallback_Gridder_LineOfSightToTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_LineOfSightToTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 */
template<class T> Callback_Gridder_LineOfSightToTargetPtr
newCallback_Gridder_LineOfSightToTarget(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_LineOfSightToTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_LineOfSightToTarget.
 */
template<class T, typename CT>
class Callback_Gridder_LineOfSightToTarget : public Callback_Gridder_LineOfSightToTarget_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_LineOfSightToTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_LineOfSightToTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 */
template<class T, typename CT> Callback_Gridder_LineOfSightToTargetPtr
newCallback_Gridder_LineOfSightToTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_LineOfSightToTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_LineOfSightToTarget.
 */
template<class T, typename CT> Callback_Gridder_LineOfSightToTargetPtr
newCallback_Gridder_LineOfSightToTarget(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_LineOfSightToTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_cancelNavigation.
 */
template<class T>
class CallbackNC_Gridder_cancelNavigation : public Callback_Gridder_cancelNavigation_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Gridder_cancelNavigation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 */
template<class T> Callback_Gridder_cancelNavigationPtr
newCallback_Gridder_cancelNavigation(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_cancelNavigation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 */
template<class T> Callback_Gridder_cancelNavigationPtr
newCallback_Gridder_cancelNavigation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_cancelNavigation<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 */
template<class T> Callback_Gridder_cancelNavigationPtr
newCallback_Gridder_cancelNavigation(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_cancelNavigation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 */
template<class T> Callback_Gridder_cancelNavigationPtr
newCallback_Gridder_cancelNavigation(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_cancelNavigation<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_cancelNavigation.
 */
template<class T, typename CT>
class Callback_Gridder_cancelNavigation : public Callback_Gridder_cancelNavigation_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Gridder_cancelNavigation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 */
template<class T, typename CT> Callback_Gridder_cancelNavigationPtr
newCallback_Gridder_cancelNavigation(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_cancelNavigation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 */
template<class T, typename CT> Callback_Gridder_cancelNavigationPtr
newCallback_Gridder_cancelNavigation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_cancelNavigation<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 */
template<class T, typename CT> Callback_Gridder_cancelNavigationPtr
newCallback_Gridder_cancelNavigation(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_cancelNavigation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_cancelNavigation.
 */
template<class T, typename CT> Callback_Gridder_cancelNavigationPtr
newCallback_Gridder_cancelNavigation(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_cancelNavigation<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getClosestFreePoint.
 */
template<class T>
class CallbackNC_Gridder_getClosestFreePoint : public Callback_Gridder_getClosestFreePoint_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const TPoint&);

    CallbackNC_Gridder_getClosestFreePoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        TPoint ret;
        try
        {
            ret = proxy->end_getClosestFreePoint(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 */
template<class T> Callback_Gridder_getClosestFreePointPtr
newCallback_Gridder_getClosestFreePoint(const IceUtil::Handle<T>& instance, void (T::*cb)(const TPoint&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getClosestFreePoint<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 */
template<class T> Callback_Gridder_getClosestFreePointPtr
newCallback_Gridder_getClosestFreePoint(T* instance, void (T::*cb)(const TPoint&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getClosestFreePoint<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getClosestFreePoint.
 */
template<class T, typename CT>
class Callback_Gridder_getClosestFreePoint : public Callback_Gridder_getClosestFreePoint_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const TPoint&, const CT&);

    Callback_Gridder_getClosestFreePoint(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        TPoint ret;
        try
        {
            ret = proxy->end_getClosestFreePoint(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 */
template<class T, typename CT> Callback_Gridder_getClosestFreePointPtr
newCallback_Gridder_getClosestFreePoint(const IceUtil::Handle<T>& instance, void (T::*cb)(const TPoint&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getClosestFreePoint<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getClosestFreePoint.
 */
template<class T, typename CT> Callback_Gridder_getClosestFreePointPtr
newCallback_Gridder_getClosestFreePoint(T* instance, void (T::*cb)(const TPoint&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getClosestFreePoint<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getDimensions.
 */
template<class T>
class CallbackNC_Gridder_getDimensions : public Callback_Gridder_getDimensions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const TDimensions&);

    CallbackNC_Gridder_getDimensions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        TDimensions ret;
        try
        {
            ret = proxy->end_getDimensions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 */
template<class T> Callback_Gridder_getDimensionsPtr
newCallback_Gridder_getDimensions(const IceUtil::Handle<T>& instance, void (T::*cb)(const TDimensions&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getDimensions<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 */
template<class T> Callback_Gridder_getDimensionsPtr
newCallback_Gridder_getDimensions(T* instance, void (T::*cb)(const TDimensions&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getDimensions<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getDimensions.
 */
template<class T, typename CT>
class Callback_Gridder_getDimensions : public Callback_Gridder_getDimensions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const TDimensions&, const CT&);

    Callback_Gridder_getDimensions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        TDimensions ret;
        try
        {
            ret = proxy->end_getDimensions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 */
template<class T, typename CT> Callback_Gridder_getDimensionsPtr
newCallback_Gridder_getDimensions(const IceUtil::Handle<T>& instance, void (T::*cb)(const TDimensions&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getDimensions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDimensions.
 */
template<class T, typename CT> Callback_Gridder_getDimensionsPtr
newCallback_Gridder_getDimensions(T* instance, void (T::*cb)(const TDimensions&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getDimensions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getDistanceToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getDistanceToTarget.
 */
template<class T>
class CallbackNC_Gridder_getDistanceToTarget : public Callback_Gridder_getDistanceToTarget_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_Gridder_getDistanceToTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        ::Ice::Float ret;
        try
        {
            ret = proxy->end_getDistanceToTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDistanceToTarget.
 */
template<class T> Callback_Gridder_getDistanceToTargetPtr
newCallback_Gridder_getDistanceToTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getDistanceToTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDistanceToTarget.
 */
template<class T> Callback_Gridder_getDistanceToTargetPtr
newCallback_Gridder_getDistanceToTarget(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getDistanceToTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getDistanceToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getDistanceToTarget.
 */
template<class T, typename CT>
class Callback_Gridder_getDistanceToTarget : public Callback_Gridder_getDistanceToTarget_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_Gridder_getDistanceToTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        ::Ice::Float ret;
        try
        {
            ret = proxy->end_getDistanceToTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDistanceToTarget.
 */
template<class T, typename CT> Callback_Gridder_getDistanceToTargetPtr
newCallback_Gridder_getDistanceToTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getDistanceToTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getDistanceToTarget.
 */
template<class T, typename CT> Callback_Gridder_getDistanceToTargetPtr
newCallback_Gridder_getDistanceToTarget(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getDistanceToTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getEstimatedTimeToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getEstimatedTimeToTarget.
 */
template<class T>
class CallbackNC_Gridder_getEstimatedTimeToTarget : public Callback_Gridder_getEstimatedTimeToTarget_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Float);

    CallbackNC_Gridder_getEstimatedTimeToTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        ::Ice::Float ret;
        try
        {
            ret = proxy->end_getEstimatedTimeToTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getEstimatedTimeToTarget.
 */
template<class T> Callback_Gridder_getEstimatedTimeToTargetPtr
newCallback_Gridder_getEstimatedTimeToTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getEstimatedTimeToTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getEstimatedTimeToTarget.
 */
template<class T> Callback_Gridder_getEstimatedTimeToTargetPtr
newCallback_Gridder_getEstimatedTimeToTarget(T* instance, void (T::*cb)(::Ice::Float), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getEstimatedTimeToTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getEstimatedTimeToTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getEstimatedTimeToTarget.
 */
template<class T, typename CT>
class Callback_Gridder_getEstimatedTimeToTarget : public Callback_Gridder_getEstimatedTimeToTarget_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Float, const CT&);

    Callback_Gridder_getEstimatedTimeToTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        ::Ice::Float ret;
        try
        {
            ret = proxy->end_getEstimatedTimeToTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getEstimatedTimeToTarget.
 */
template<class T, typename CT> Callback_Gridder_getEstimatedTimeToTargetPtr
newCallback_Gridder_getEstimatedTimeToTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getEstimatedTimeToTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getEstimatedTimeToTarget.
 */
template<class T, typename CT> Callback_Gridder_getEstimatedTimeToTargetPtr
newCallback_Gridder_getEstimatedTimeToTarget(T* instance, void (T::*cb)(::Ice::Float, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getEstimatedTimeToTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getMap.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getMap.
 */
template<class T>
class CallbackNC_Gridder_getMap : public Callback_Gridder_getMap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Map&);

    CallbackNC_Gridder_getMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Map ret;
        try
        {
            ret = proxy->end_getMap(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getMap.
 */
template<class T> Callback_Gridder_getMapPtr
newCallback_Gridder_getMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const Map&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getMap<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getMap.
 */
template<class T> Callback_Gridder_getMapPtr
newCallback_Gridder_getMap(T* instance, void (T::*cb)(const Map&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getMap<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getMap.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getMap.
 */
template<class T, typename CT>
class Callback_Gridder_getMap : public Callback_Gridder_getMap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Map&, const CT&);

    Callback_Gridder_getMap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Map ret;
        try
        {
            ret = proxy->end_getMap(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getMap.
 */
template<class T, typename CT> Callback_Gridder_getMapPtr
newCallback_Gridder_getMap(const IceUtil::Handle<T>& instance, void (T::*cb)(const Map&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getMap<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getMap.
 */
template<class T, typename CT> Callback_Gridder_getMapPtr
newCallback_Gridder_getMap(T* instance, void (T::*cb)(const Map&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getMap<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getNavigationState.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getNavigationState.
 */
template<class T>
class CallbackNC_Gridder_getNavigationState : public Callback_Gridder_getNavigationState_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(NavigationState);

    CallbackNC_Gridder_getNavigationState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        NavigationState ret;
        try
        {
            ret = proxy->end_getNavigationState(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getNavigationState.
 */
template<class T> Callback_Gridder_getNavigationStatePtr
newCallback_Gridder_getNavigationState(const IceUtil::Handle<T>& instance, void (T::*cb)(NavigationState), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getNavigationState<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getNavigationState.
 */
template<class T> Callback_Gridder_getNavigationStatePtr
newCallback_Gridder_getNavigationState(T* instance, void (T::*cb)(NavigationState), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getNavigationState<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getNavigationState.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getNavigationState.
 */
template<class T, typename CT>
class Callback_Gridder_getNavigationState : public Callback_Gridder_getNavigationState_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(NavigationState, const CT&);

    Callback_Gridder_getNavigationState(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        NavigationState ret;
        try
        {
            ret = proxy->end_getNavigationState(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getNavigationState.
 */
template<class T, typename CT> Callback_Gridder_getNavigationStatePtr
newCallback_Gridder_getNavigationState(const IceUtil::Handle<T>& instance, void (T::*cb)(NavigationState, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getNavigationState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getNavigationState.
 */
template<class T, typename CT> Callback_Gridder_getNavigationStatePtr
newCallback_Gridder_getNavigationState(T* instance, void (T::*cb)(NavigationState, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getNavigationState<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getNavigationStatus.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getNavigationStatus.
 */
template<class T>
class CallbackNC_Gridder_getNavigationStatus : public Callback_Gridder_getNavigationStatus_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const NavigationStatus&);

    CallbackNC_Gridder_getNavigationStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        NavigationStatus ret;
        try
        {
            ret = proxy->end_getNavigationStatus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getNavigationStatus.
 */
template<class T> Callback_Gridder_getNavigationStatusPtr
newCallback_Gridder_getNavigationStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const NavigationStatus&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getNavigationStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getNavigationStatus.
 */
template<class T> Callback_Gridder_getNavigationStatusPtr
newCallback_Gridder_getNavigationStatus(T* instance, void (T::*cb)(const NavigationStatus&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getNavigationStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getNavigationStatus.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getNavigationStatus.
 */
template<class T, typename CT>
class Callback_Gridder_getNavigationStatus : public Callback_Gridder_getNavigationStatus_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const NavigationStatus&, const CT&);

    Callback_Gridder_getNavigationStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        NavigationStatus ret;
        try
        {
            ret = proxy->end_getNavigationStatus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getNavigationStatus.
 */
template<class T, typename CT> Callback_Gridder_getNavigationStatusPtr
newCallback_Gridder_getNavigationStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const NavigationStatus&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getNavigationStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getNavigationStatus.
 */
template<class T, typename CT> Callback_Gridder_getNavigationStatusPtr
newCallback_Gridder_getNavigationStatus(T* instance, void (T::*cb)(const NavigationStatus&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getNavigationStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getPaths.
 */
template<class T>
class CallbackNC_Gridder_getPaths : public Callback_Gridder_getPaths_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Result&);

    CallbackNC_Gridder_getPaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Result ret;
        try
        {
            ret = proxy->end_getPaths(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 */
template<class T> Callback_Gridder_getPathsPtr
newCallback_Gridder_getPaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const Result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getPaths<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 */
template<class T> Callback_Gridder_getPathsPtr
newCallback_Gridder_getPaths(T* instance, void (T::*cb)(const Result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getPaths<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getPaths.
 */
template<class T, typename CT>
class Callback_Gridder_getPaths : public Callback_Gridder_getPaths_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Result&, const CT&);

    Callback_Gridder_getPaths(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Result ret;
        try
        {
            ret = proxy->end_getPaths(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 */
template<class T, typename CT> Callback_Gridder_getPathsPtr
newCallback_Gridder_getPaths(const IceUtil::Handle<T>& instance, void (T::*cb)(const Result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getPaths<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPaths.
 */
template<class T, typename CT> Callback_Gridder_getPathsPtr
newCallback_Gridder_getPaths(T* instance, void (T::*cb)(const Result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getPaths<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getPose.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getPose.
 */
template<class T>
class CallbackNC_Gridder_getPose : public Callback_Gridder_getPose_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Pose&);

    CallbackNC_Gridder_getPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Pose ret;
        try
        {
            ret = proxy->end_getPose(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPose.
 */
template<class T> Callback_Gridder_getPosePtr
newCallback_Gridder_getPose(const IceUtil::Handle<T>& instance, void (T::*cb)(const Pose&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getPose<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPose.
 */
template<class T> Callback_Gridder_getPosePtr
newCallback_Gridder_getPose(T* instance, void (T::*cb)(const Pose&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getPose<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getPose.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getPose.
 */
template<class T, typename CT>
class Callback_Gridder_getPose : public Callback_Gridder_getPose_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Pose&, const CT&);

    Callback_Gridder_getPose(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Pose ret;
        try
        {
            ret = proxy->end_getPose(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPose.
 */
template<class T, typename CT> Callback_Gridder_getPosePtr
newCallback_Gridder_getPose(const IceUtil::Handle<T>& instance, void (T::*cb)(const Pose&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getPose<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getPose.
 */
template<class T, typename CT> Callback_Gridder_getPosePtr
newCallback_Gridder_getPose(T* instance, void (T::*cb)(const Pose&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getPose<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getTarget.
 */
template<class T>
class CallbackNC_Gridder_getTarget : public Callback_Gridder_getTarget_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const TPoint&);

    CallbackNC_Gridder_getTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        TPoint ret;
        try
        {
            ret = proxy->end_getTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getTarget.
 */
template<class T> Callback_Gridder_getTargetPtr
newCallback_Gridder_getTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(const TPoint&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getTarget.
 */
template<class T> Callback_Gridder_getTargetPtr
newCallback_Gridder_getTarget(T* instance, void (T::*cb)(const TPoint&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_getTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_getTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_getTarget.
 */
template<class T, typename CT>
class Callback_Gridder_getTarget : public Callback_Gridder_getTarget_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const TPoint&, const CT&);

    Callback_Gridder_getTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        TPoint ret;
        try
        {
            ret = proxy->end_getTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getTarget.
 */
template<class T, typename CT> Callback_Gridder_getTargetPtr
newCallback_Gridder_getTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(const TPoint&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_getTarget.
 */
template<class T, typename CT> Callback_Gridder_getTargetPtr
newCallback_Gridder_getTarget(T* instance, void (T::*cb)(const TPoint&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_getTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_hasReachedTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_hasReachedTarget.
 */
template<class T>
class CallbackNC_Gridder_hasReachedTarget : public Callback_Gridder_hasReachedTarget_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_hasReachedTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_hasReachedTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_hasReachedTarget.
 */
template<class T> Callback_Gridder_hasReachedTargetPtr
newCallback_Gridder_hasReachedTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_hasReachedTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_hasReachedTarget.
 */
template<class T> Callback_Gridder_hasReachedTargetPtr
newCallback_Gridder_hasReachedTarget(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_hasReachedTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_hasReachedTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_hasReachedTarget.
 */
template<class T, typename CT>
class Callback_Gridder_hasReachedTarget : public Callback_Gridder_hasReachedTarget_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_hasReachedTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_hasReachedTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_hasReachedTarget.
 */
template<class T, typename CT> Callback_Gridder_hasReachedTargetPtr
newCallback_Gridder_hasReachedTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_hasReachedTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_hasReachedTarget.
 */
template<class T, typename CT> Callback_Gridder_hasReachedTargetPtr
newCallback_Gridder_hasReachedTarget(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_hasReachedTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_replanPath.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_replanPath.
 */
template<class T>
class CallbackNC_Gridder_replanPath : public Callback_Gridder_replanPath_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_replanPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_replanPath(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_replanPath.
 */
template<class T> Callback_Gridder_replanPathPtr
newCallback_Gridder_replanPath(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_replanPath<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_replanPath.
 */
template<class T> Callback_Gridder_replanPathPtr
newCallback_Gridder_replanPath(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_replanPath<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_replanPath.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_replanPath.
 */
template<class T, typename CT>
class Callback_Gridder_replanPath : public Callback_Gridder_replanPath_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_replanPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_replanPath(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_replanPath.
 */
template<class T, typename CT> Callback_Gridder_replanPathPtr
newCallback_Gridder_replanPath(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_replanPath<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_replanPath.
 */
template<class T, typename CT> Callback_Gridder_replanPathPtr
newCallback_Gridder_replanPath(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_replanPath<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_resumeNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_resumeNavigation.
 */
template<class T>
class CallbackNC_Gridder_resumeNavigation : public Callback_Gridder_resumeNavigation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_resumeNavigation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_resumeNavigation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_resumeNavigation.
 */
template<class T> Callback_Gridder_resumeNavigationPtr
newCallback_Gridder_resumeNavigation(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_resumeNavigation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_resumeNavigation.
 */
template<class T> Callback_Gridder_resumeNavigationPtr
newCallback_Gridder_resumeNavigation(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_resumeNavigation<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_resumeNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_resumeNavigation.
 */
template<class T, typename CT>
class Callback_Gridder_resumeNavigation : public Callback_Gridder_resumeNavigation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_resumeNavigation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_resumeNavigation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_resumeNavigation.
 */
template<class T, typename CT> Callback_Gridder_resumeNavigationPtr
newCallback_Gridder_resumeNavigation(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_resumeNavigation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_resumeNavigation.
 */
template<class T, typename CT> Callback_Gridder_resumeNavigationPtr
newCallback_Gridder_resumeNavigation(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_resumeNavigation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setGridDimensions.
 */
template<class T>
class CallbackNC_Gridder_setGridDimensions : public Callback_Gridder_setGridDimensions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_setGridDimensions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setGridDimensions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 */
template<class T> Callback_Gridder_setGridDimensionsPtr
newCallback_Gridder_setGridDimensions(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setGridDimensions<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 */
template<class T> Callback_Gridder_setGridDimensionsPtr
newCallback_Gridder_setGridDimensions(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setGridDimensions<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setGridDimensions.
 */
template<class T, typename CT>
class Callback_Gridder_setGridDimensions : public Callback_Gridder_setGridDimensions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_setGridDimensions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setGridDimensions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 */
template<class T, typename CT> Callback_Gridder_setGridDimensionsPtr
newCallback_Gridder_setGridDimensions(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setGridDimensions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setGridDimensions.
 */
template<class T, typename CT> Callback_Gridder_setGridDimensionsPtr
newCallback_Gridder_setGridDimensions(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setGridDimensions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setLocationAndGetPath.
 */
template<class T>
class CallbackNC_Gridder_setLocationAndGetPath : public Callback_Gridder_setLocationAndGetPath_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const Result&);

    CallbackNC_Gridder_setLocationAndGetPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Result ret;
        try
        {
            ret = proxy->end_setLocationAndGetPath(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 */
template<class T> Callback_Gridder_setLocationAndGetPathPtr
newCallback_Gridder_setLocationAndGetPath(const IceUtil::Handle<T>& instance, void (T::*cb)(const Result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setLocationAndGetPath<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 */
template<class T> Callback_Gridder_setLocationAndGetPathPtr
newCallback_Gridder_setLocationAndGetPath(T* instance, void (T::*cb)(const Result&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setLocationAndGetPath<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setLocationAndGetPath.
 */
template<class T, typename CT>
class Callback_Gridder_setLocationAndGetPath : public Callback_Gridder_setLocationAndGetPath_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const Result&, const CT&);

    Callback_Gridder_setLocationAndGetPath(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        Result ret;
        try
        {
            ret = proxy->end_setLocationAndGetPath(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 */
template<class T, typename CT> Callback_Gridder_setLocationAndGetPathPtr
newCallback_Gridder_setLocationAndGetPath(const IceUtil::Handle<T>& instance, void (T::*cb)(const Result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setLocationAndGetPath<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setLocationAndGetPath.
 */
template<class T, typename CT> Callback_Gridder_setLocationAndGetPathPtr
newCallback_Gridder_setLocationAndGetPath(T* instance, void (T::*cb)(const Result&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setLocationAndGetPath<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setTarget.
 */
template<class T>
class CallbackNC_Gridder_setTarget : public Callback_Gridder_setTarget_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_setTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setTarget.
 */
template<class T> Callback_Gridder_setTargetPtr
newCallback_Gridder_setTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setTarget.
 */
template<class T> Callback_Gridder_setTargetPtr
newCallback_Gridder_setTarget(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setTarget<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setTarget.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setTarget.
 */
template<class T, typename CT>
class Callback_Gridder_setTarget : public Callback_Gridder_setTarget_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_setTarget(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setTarget(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setTarget.
 */
template<class T, typename CT> Callback_Gridder_setTargetPtr
newCallback_Gridder_setTarget(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setTarget.
 */
template<class T, typename CT> Callback_Gridder_setTargetPtr
newCallback_Gridder_setTarget(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setTarget<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setTargetWithOptions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setTargetWithOptions.
 */
template<class T>
class CallbackNC_Gridder_setTargetWithOptions : public Callback_Gridder_setTargetWithOptions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_setTargetWithOptions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setTargetWithOptions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setTargetWithOptions.
 */
template<class T> Callback_Gridder_setTargetWithOptionsPtr
newCallback_Gridder_setTargetWithOptions(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setTargetWithOptions<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setTargetWithOptions.
 */
template<class T> Callback_Gridder_setTargetWithOptionsPtr
newCallback_Gridder_setTargetWithOptions(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_setTargetWithOptions<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_setTargetWithOptions.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_setTargetWithOptions.
 */
template<class T, typename CT>
class Callback_Gridder_setTargetWithOptions : public Callback_Gridder_setTargetWithOptions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_setTargetWithOptions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_setTargetWithOptions(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setTargetWithOptions.
 */
template<class T, typename CT> Callback_Gridder_setTargetWithOptionsPtr
newCallback_Gridder_setTargetWithOptions(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setTargetWithOptions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_setTargetWithOptions.
 */
template<class T, typename CT> Callback_Gridder_setTargetWithOptionsPtr
newCallback_Gridder_setTargetWithOptions(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_setTargetWithOptions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_startNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_startNavigation.
 */
template<class T>
class CallbackNC_Gridder_startNavigation : public Callback_Gridder_startNavigation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Gridder_startNavigation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_startNavigation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_startNavigation.
 */
template<class T> Callback_Gridder_startNavigationPtr
newCallback_Gridder_startNavigation(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_startNavigation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_startNavigation.
 */
template<class T> Callback_Gridder_startNavigationPtr
newCallback_Gridder_startNavigation(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_startNavigation<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_startNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_startNavigation.
 */
template<class T, typename CT>
class Callback_Gridder_startNavigation : public Callback_Gridder_startNavigation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Gridder_startNavigation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        GridderPrx proxy = GridderPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_startNavigation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_startNavigation.
 */
template<class T, typename CT> Callback_Gridder_startNavigationPtr
newCallback_Gridder_startNavigation(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_startNavigation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_startNavigation.
 */
template<class T, typename CT> Callback_Gridder_startNavigationPtr
newCallback_Gridder_startNavigation(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_startNavigation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_stopNavigation.
 */
template<class T>
class CallbackNC_Gridder_stopNavigation : public Callback_Gridder_stopNavigation_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Gridder_stopNavigation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 */
template<class T> Callback_Gridder_stopNavigationPtr
newCallback_Gridder_stopNavigation(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_stopNavigation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 */
template<class T> Callback_Gridder_stopNavigationPtr
newCallback_Gridder_stopNavigation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_stopNavigation<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 */
template<class T> Callback_Gridder_stopNavigationPtr
newCallback_Gridder_stopNavigation(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_stopNavigation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 */
template<class T> Callback_Gridder_stopNavigationPtr
newCallback_Gridder_stopNavigation(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Gridder_stopNavigation<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 * Create a wrapper instance by calling ::RoboCompGridder::newCallback_Gridder_stopNavigation.
 */
template<class T, typename CT>
class Callback_Gridder_stopNavigation : public Callback_Gridder_stopNavigation_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Gridder_stopNavigation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 */
template<class T, typename CT> Callback_Gridder_stopNavigationPtr
newCallback_Gridder_stopNavigation(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_stopNavigation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 */
template<class T, typename CT> Callback_Gridder_stopNavigationPtr
newCallback_Gridder_stopNavigation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_stopNavigation<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 */
template<class T, typename CT> Callback_Gridder_stopNavigationPtr
newCallback_Gridder_stopNavigation(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_stopNavigation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::RoboCompGridder::Gridder::begin_stopNavigation.
 */
template<class T, typename CT> Callback_Gridder_stopNavigationPtr
newCallback_Gridder_stopNavigation(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Gridder_stopNavigation<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
